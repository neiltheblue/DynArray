#ifndef DYN_ARRAY
#define DYN_ARRAY

/**
 * @file dynarray.h
 *
 * @brief Dynamic Array header file
 *
 * TODO list:
 *
 * - quick sort
 * - dirty flag for add
 * - dirty flag for set
 * - add free spare memory
 * - array reverse
 * - array copy
 *
 */

#include <stdio.h>

/**
 * @brief Dynamic array type declaration
 *
 * This declaration should be added to an applications header, which will
 * generate the method and structure declarations required to support
 * a new dynamic array type.
 *
 * For example:
 *
 * DECLARE_DYNARRAY_TYPE(long, dynArrayLong)
 *
 * This will generate a new dynamic array type called 'dynArray_long' that
 * will store an array of 'long' values.
 *
 * Note: The same dynamic array type may be applied to more than one
 * dynamic type definition.
 *
 * @param TYPE the data type that will be stored in the dynamic array
 * @param NAME the name of the new dynamic array type
 */
#define DECLARE_DYNARRAY_TYPE(TYPE, NAME)                                      \
                                                                               \
  typedef struct DynamicArrayStruct_##TYPE {                                   \
    size_t elementSize;                                                        \
    size_t size;                                                               \
    size_t capacity;                                                           \
    float growth;                                                              \
    TYPE *array;                                                               \
    void (*set)(const void *pDA, const size_t index, const void *value);       \
    void (*get)(const void *pDA, const size_t index, void *value);             \
  } NAME;                                                                      \
                                                                               \
  size_t setDA##NAME(const NAME *pDA, const size_t index, TYPE value);         \
                                                                               \
  void getDA##NAME(const NAME *pDA, const size_t index, TYPE *value);          \
                                                                               \
  size_t addDA##NAME(const NAME *pDA, TYPE value);                             \
                                                                               \
  size_t addAllDA##NAME(const NAME *pDA, const TYPE *src, size_t first,        \
                        size_t length);

/**
 * @private
 */
typedef struct DynamicArrayStructVoid {
  size_t elementSize;
  size_t size;
  size_t capacity;
  float growth;
  void *array;
  void (*set)(const void *pDA, const size_t index, const void *value);
  void (*get)(const void *pDA, const size_t index, void *value);
} _dynArrayVoid;

/**
 * @brief Dynamic array type definition
 *
 * This definition should be added to an applications source file, which will
 * generate the method and structure definitions required to support
 * a new typed dynamic array.
 *
 * For example:
 *
 * DEFINE_DYNARRAY_TYPE(long, dynArrayLong, dynArray)
 *
 * This will generate a new dynamic array constructor method called
 * 'dynArray' that will use the 'dynArrayLong' dynamic array data structure,
 * to store an array of 'long' values:
 *
 * dynArrayLong *pDA = dynArray((DynArrayParams){.size = 10});
 *
 * Another constructor method will also
 * be created with form <NAME>Default which will provide default parameters:
 *
 * dynArrayLong *pDA = dynArrayDefault();
 *
 * This macro will also generate a typed value function implementations:
 *
 * size_t setDA<NAME>(const <STRUCT> *pDA, const size_t index, <TYPE> value)
 *
 * size_t addDA<NAME>(<STRUCT> *pDA, <TYPE> value)
 *
 * void getDA<NAME>(const <STRUCT> *pDA, const size_t index, <TYPE> *value)
 *
 * Where NAME is the name of the new array method and TYPE is the element type.
 *
 *
 * @param TYPE the data type that will be stored in the dynamic array
 * @param STRUCT the name of the dynamic array type generated by
 * DECLARE_DYNARRAY_TYPE()
 * @param NAME the name of the new method that will create a typed dynamic array
 *
 */
#define DEFINE_DYNARRAY_TYPE(TYPE, STRUCT, NAME)                               \
                                                                               \
  size_t setDA##NAME(const STRUCT *pDA, const size_t index, TYPE value) {      \
    return setDA(pDA, index, &value);                                          \
  }                                                                            \
                                                                               \
  void getDA##NAME(const STRUCT *pDA, const size_t index, TYPE *value) {       \
    getDA(pDA, index, value);                                                  \
  }                                                                            \
                                                                               \
  size_t addDA##NAME(STRUCT *pDA, TYPE value) { return addDA(pDA, &value); }   \
                                                                               \
  size_t addAllDA##NAME(STRUCT *pDA, const TYPE *src, size_t first,            \
                        size_t length) {                                       \
    return addAllDA(pDA, src, first, length);                                  \
  }                                                                            \
                                                                               \
  void _setter_##NAME(const void *pDA, const size_t index,                     \
                      const void *value) {                                     \
    *(((STRUCT *)pDA)->array + index) = *(TYPE *)value;                        \
  }                                                                            \
                                                                               \
  void _getter_##NAME(const void *pDA, const size_t index, void *value) {      \
    *(TYPE *)value = *(((STRUCT *)pDA)->array + index);                        \
  }                                                                            \
                                                                               \
  STRUCT *NAME(const DynArrayParams params) {                                  \
    return _createDynArray(params, sizeof(STRUCT), sizeof(TYPE),               \
                           _setter_##NAME, _getter_##NAME);                    \
  }                                                                            \
                                                                               \
  STRUCT *NAME##Default() {                                                    \
    return NAME((DynArrayParams){.capacity = 10, .growth = 1.5, .size = 0});   \
  }

/**                                                                            \
 * @brief Parameter structure for creating a new dynamic array                 \
 *                                                                             \
 * This struct is for use with the helper                                      \
 * macro DEFINE_DYNARRAY_TYPE().                                               \
 *                                                                             \
 * If the size is greater than 0 the initial capacity will be extended.        \
 *                                                                             \
 * The growth factor must be greater than 1.0 as it is used to extend the      \
 * current capacity.                                                           \
 */
typedef struct DynamicArrayParams {
  size_t size;     ///< the initial array size
  float growth;    ///< the growth factor for the array
  size_t capacity; ///< the initial reserved capacity for the array

} DynArrayParams;

/**
 * @brief Create a new dynamic array.
 *
 * The helper macro DEFINE_DYNARRAY_TYPE uses this call to create a new
 * dynamic array function.
 *
 * @param params the parameter structure
 * @param structSize the structure size to reserve
 * @param elementSize the element size to reserve
 * @param setter the typed value setter function
 * @param getter the typed value getter function
 * @return An initialised dynamic array that
 *          should be freed with freeDA()
 */
void *_createDynArray(
    DynArrayParams params, size_t structSize, size_t elementSize,
    void (*setter)(const void *pDA, const size_t index, const void *value),
    void (*getter)(const void *pDA, const size_t index, void *value));

/**
 * @brief Free a dynamic array instance
 * @param pDA the dynamic array pointer to free
 */
void freeDA(void *pDA);

/**
 * @brief Set a dynamic array value
 * @param pDA the array pointer to update
 * @param index the index to set
 * @param value the value to apply
 * @return the updated index
 */
size_t setDA(const void *pDA, const size_t index, const void *value);

/**
 * @brief Add a dynamic array value
 * @param pDA the array pointer to update
 * @param value the value to apply
 * @return the updated index
 */
size_t addDA(void *pDA, const void *value);

/**
 * @brief Add a dynamic array value
 * @param pDA the array pointer to update
 * @param src the source value array
 * @param first the first index to add
 * @param length the number of elements to copy
 * @return the last updated index
 */
size_t addAllDA(void *pDA, const void *src, size_t first, size_t length);

/**
 * @brief Get a dynamic array value
 * @param pDA the array pointer to update
 * @param index the index to read
 * @param value the value pointer to set
 */
void getDA(const void *pDA, const size_t index, void *value);

/**
 * @brief Dump the dynamic array description
 * @param pDA the array pointer to dump
 * @param stream the stream to dump to
 */
void dumpDA(const void *pDA, FILE *stream);

#endif // DYN_ARRAY
